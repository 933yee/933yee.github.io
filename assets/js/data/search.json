[ { "title": "UVA-11463 Commandos", "url": "/posts/uva-11463/", "categories": "Code, UVA", "tags": "uva, floyd-warshall", "date": "2022-11-17 01:27:00 +0800", "snippet": "Problem Link作法Floyd-WarshallCode#include &lt;bits/stdc++.h&gt;using namespace std;int t, n, m, u, v, s, d;int dis[105][105];int main(){ cin &gt;&gt; t; for(int c = 1; c &lt;= t; c++){ cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; 105; i++) for(int j = 0; j &lt; 105; j++) dis[i][j] = (i == j) ? 0 : 105; for(int i = 0; i &lt; m; i++){ cin &gt;&gt; u &gt;&gt; v; dis[u][v] = dis[v][u] = 1; } for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; n; j++) for(int k = 0; k &lt; n; k++) if(dis[j][i] + dis[i][k] &lt; dis[j][k]) dis[j][k] = dis[j][i] + dis[i][k]; cin &gt;&gt; s &gt;&gt; d; int mx = -1; for(int i = 0; i &lt; n; i++) mx = max(mx, dis[s][i] + dis[i][d]); cout &lt;&lt; \"Case \" &lt;&lt; c &lt;&lt; \": \" &lt;&lt; mx &lt;&lt; '\\n'; }}" }, { "title": "UVA-558 Wormholes", "url": "/posts/uva-558/", "categories": "Code, UVA", "tags": "uva, bellman-ford", "date": "2022-11-17 00:47:00 +0800", "snippet": "Problem Link作法Bellman-FordCode#include &lt;bits/stdc++.h&gt;using namespace std;int t, n, m, u, v, w;vector&lt;tuple&lt;int, int, int&gt;&gt; edges;vector&lt;int&gt; dist;int main(){ cin &gt;&gt; t; while(t--){ cin &gt;&gt; n &gt;&gt; m; edges.clear(); dist.clear(); dist.resize(n, INT_MAX/2); for(int i=0; i&lt;m; i++){ cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; edges.emplace_back(u, v, w); } dist[0] = 0; for(int i=0; i&lt;n; i++){ bool update = false; for(auto j: edges){ tie(u, v, w) = j; if(dist[v] &gt; dist[u] + w){ dist[v] = dist[u] + w; update = true; } } if(!update){ cout &lt;&lt; \"not possible\\n\"; break; } if(i == n-1){ cout &lt;&lt; \"possible\\n\"; break; } } }}" }, { "title": "Trees", "url": "/posts/trees/", "categories": "Code, Others, Trees, Data Structure", "tags": "trees, data structure", "date": "2022-10-22 19:49:00 +0800", "snippet": "Left Child-Right Sibling Property Each node has exactly two link fields Left link(child): points to leftmost child node. Right link(sibling): points to closest sibling node. Rotate clockwise 45° Special Binary Tree Full binary tree A binary tree of depth k which has 2k – 1 nodes Complete binary tree All the levels of the tree are filled completely except the lowest level nodes which are filled from as left as possible. Traversal Preorder recursive void traversal_preorder_recursive(node* cur){ if(!cur) return; cout &lt;&lt; cur-&gt;data &lt;&lt; ' '; traversal_preorder_recursive(cur-&gt;left); traversal_preorder_recursive(cur-&gt;right); } iterative void traversal_preorder_non_recursive(node* root){ stack&lt;node*&gt; st; st.push(root); while(1){ if(st.empty()) break; node* current = st.top(); cout &lt;&lt; current-&gt;data &lt;&lt; ' '; st.pop(); if(current-&gt;right) st.push(current-&gt;right); if(current-&gt;left) st.push(current-&gt;left); } } Inorder recursive void traversal_inorder_recursive(node* cur){ if(!cur) return; traversal_inorder_recursive(cur-&gt;left); cout &lt;&lt; cur-&gt;data &lt;&lt; ' '; traversal_inorder_recursive(cur-&gt;right); } iterative void traversal_inorder_non_recursive(node* root){ stack&lt;node*&gt; st; node* current = root; while(1){ while(current){ st.push(current); current = current-&gt;left; } if(st.empty()) break; current = st.top(); cout &lt;&lt; current-&gt;data &lt;&lt; ' '; st.pop(); current = current-&gt;right; } } Postorder recursive void traversal_postorder_recursive(node* cur){ if(!cur) return; traversal_postorder_recursive(cur-&gt;left); traversal_postorder_recursive(cur-&gt;right); cout &lt;&lt; cur-&gt;data &lt;&lt; ' '; } iterative void traversal_postorder_non_recursive(node* root){ stack&lt;node*&gt; st; node* current = root; while(1){ while(current){ st.push(current); st.push(current); current = current-&gt;left; } if(st.empty()) break; current = st.top(); st.pop(); if(!st.empty() &amp;&amp; st.top() == current){ current = current-&gt;right; }else{ cout &lt;&lt; current-&gt;data &lt;&lt; ' '; current = nullptr; } } } Level-order void traversal_level_order(node* root){ queue&lt;node*&gt; q; q.push(root); while(!q.empty()){ node* current = q.front(); q.pop(); cout &lt;&lt; current-&gt;data &lt;&lt; ' '; if(current-&gt;left) q.push(current-&gt;left); if(current-&gt;right) q.push(current-&gt;right); } } Binary Search Tree Property Every element has a key and no two elements have the same key. The keys (if any) in the left subtree are smaller than the key in the root. The keys (if any) in the right subtree are larger than the key in the root. The left and right subtrees are also BST. Inorder traversal of a BST will result in a sorted list. Search an Element Start from root Compare the key with root ’&lt;’ search the left subtree ’&gt;’ search the right subtree Repeat step 2 until the key is found or a leaf is visited Search an Element by Rank To facilitate searching for rank-r element, we store the additional information, leftSize leftSize = 1 + # of nodes in left subtree If we are searching for the rank-r element, we perform: Set currentNode = root Consider 3 cases leftSize &gt; r: currentNode = left child; repeat (2) leftSize &lt; r: r = r – leftSize; currentNode = right child, repeat (2) leftSize = r: bingo; break Example Insert First we search for the existence of the element. If the search is unsuccessful, then the element is inserted at the point the search terminates. Delete Steps: delete an element with key k Search for the key k If the search is successful, we have to deal three scenarios The element is a leaf node The element is a non-leaf node with one child The element is a non-leaf node with two children Min and Max element Min (Max) element is at the leftmost (rightmost) of the tree. Min or max are not always terminal nodes. Min or max has at most one child. Scenario 1 : The element is a leaf node The child field of parent node is set to NULL Dispose the node Scenario 2 : The element is a non-leaf node with one child Simply change the pointer from the parent node to the single-child node . Dispose the node Scenario 3 : The element is a non-leaf node with two children The deleted element is replaced by either the smallest element in right subtree the largest element in left subtree Delete the node and replace by: A leaf node \\(\\rightarrow\\) apply scenario 1 A non-leaf node with one child \\(\\rightarrow\\) apply scenario 2 Balanced The worst-case is caused by the lack of tree balance. Linked list How to Keep a Balanced BST ? AVL Trees Red-black Trees Splay Trees Self adjusting trees B-trees Multiway search trees AVL Trees A height-balanced binary search tree. Each node in an AVL tree stores the current node height for calculating the balance factor . Height-balanced &amp; Blance factor: An empty tree is height balanced. If 𝑻 is a non-empty binary tree with 𝑻𝑳 and 𝑻𝑹 as its left and right subtrees respectively: Balance factor 𝑏𝑓(𝑻) = ℎ𝑒𝑖𝑔ℎ𝑡(𝑻𝑳) − ℎ𝑒𝑖𝑔ℎ𝑡(𝑻𝑹) 𝑻 is height balanced iff: 𝑻𝑳 and 𝑻𝑹 are height balanced. \\(\\vert\\) 𝑏𝑓(𝑻) \\(\\vert\\) ≤ 1 Rebalancing BST insertion/deletion operation may cause imblance Steps Update the heights (balance factors) from the inserted/deleted node up to the root . Fix unbalanced situations using rotations. Unbalanced Situations There are 4 kinds of imbalanced situations: 2 outside cases: require single rotation (LL, RR) 2 inside cases: require double rotation (LR, RL) Forest Definition A forest is a set of n ≥ 0 disjoint trees Operations Transforming a forest to binary tree Apply left child-right sibling approach Convert each tree into binary tree Connect two binary trees, T1 and T2, by setting the rightChild of root(T1) to the root(T2) Forest traversals Assume we have a forest F and corresponding binary tree T, then Preorder (inorder) traversal of T is equivalent to visiting the nodes of F in forest preorder (inorder) Disjoint Sets Definition Assume a set S of n integers {0, 1, 2,…, n-1} is divided into several subsets S1, S2, … , Sk and Si ∩ Sj = ф for any i, j є { 1, … , k } and i ≠ j Operations Disjoint set union : Union(Si, Sj) Si = Si U Sj or Sj = Si U Sj Find the set containing element x : Find(x) Example Set S = { 0, 1, 2, 3, 4, 5 } Disjoint subsets S1 = { 0, 2, 3 } S2 = { 1 } S3 = { 4, 5 } Union(S1, S2) = { 0, 1, 2, 3 } Find(5) = 3 Array Representation Using a sequential mapping array where index represents set members and array value indicates set name Example S = { 0, 1, 2, 3, 4, 5 } with subsets S1 = { 0, 2, 3 }, S2 = { 1 } and S3 = { 4, 5 } Find(x) Complexity = O(1) Find(5) = S[5] = set 3 Find(3) = S[3] = set 1 Union(Si, Sj) Assume we always merge the 2nd set to 1st set , that is Si = Si U Sj Scan the array and set S[k] to i if S[k] == j S2 = Union(S2, S3) Time Complexity S = { 0, 1, 2, … , n-1 } S1 = { 0 }, S2 = { 1 }, S3 = { 2 }, … , Sn = { n-1 } Union Union(S2, S1), Union(S3, S2), …, Union(Sn, Sn-1) (n-1)*O(n) = O(n2) Find Find(0), Find(1), …, Find(n-1) n*O(1) = O(n) Total time complexity = O(n2) Tree Representation Use an array to store the tree. Identify the set by the root of the tree. Union(Si, Sj) Set the parent field of one of the root to the other root. S1 = Union(S1, S3) Time complexity : O(1) Find(x) Following the index starting at x and tracing the tree structure until reaching a node with parent value = itself Use the root to identify the set name Time Complexity S = { 0, 1, 2, … , n-1 } S1 = { 0 }, S2 = { 1 }, S3 = { 2 }, … , Sn = { n-1 } Union Union(S2, S1), Union(S3, S2), …, Union(Sn, Sn-1) Followed by a sequence of Find Find(0), Find(1), …, Find(n-1) Total time complexity = 1 + 2 + 3 + … + n = O(n2) Improved Union(Si, Sj) Do not always merge two sets into the first set Adopt a Weighting rule to union operation Si = Si U Sj, if \\(\\vert\\) Si \\(\\vert\\) ≥ \\(\\vert\\) Sj \\(\\vert\\) Sj = Si U Sj, if \\(\\vert\\) Si \\(\\vert\\) &lt; \\(\\vert\\) Sj \\(\\vert\\) That is, make small tree connect to bigger tree Example S = { 0, 1, 2, … , n-1 } S1 = { 0 }, S2 = { 1 }, S3 = { 2 }, … , Sn = { n-1 } Union(S1, S2), Union(S1, S3), Union(S1, S4) Let T be a tree with m nodes created by a sequence of weighting unions. The height of T is no greater than \\(\\lfloor\\) log2m \\(\\rfloor\\) + 1 . " }, { "title": "Expressions", "url": "/posts/expressions/", "categories": "Code, Others, Expressions, Data Structure", "tags": "expressions, data structure", "date": "2022-10-05 14:01:00 +0800", "snippet": "Infix Property Operator comes in-between the operands. Ambiguous. Need parentheses to make them unambiguous. Hard to evaluate using codes. Postfix Property Each operator appears after its operands. No need parentheses . Priority of operators is no longer relevant. Postfix notations can be used in intermediate code generation in compiler design. Easier to parse for a machine. Evaluation Step Making a left to right scan. Stacking operands. Evaluating operators. Push the result into stack. Example A B + C + push A push B (detecting an operator) pop two operands out and push the result after calculating them push C (detecting an operator) pop two operands out and push the result after calculating them             The result is (A + B) + C .Prefix Property Each operator appears before its operands. No need parentheses . Priority of operators is no longer relevant. Easier to parse for a machine. Evaluation Step The same as evaluating postfix, but read from right to left Example / A * B C push C push B (detecting an operator) pop two operands out and push the result after calculating them push A (detecting an operator) pop two operands out and push the result after calculating them             The result is A / (B * C) .Conversion Infix to Postfix Rules Because the order of operands does not change , we can just output every visting operand directly. Utilize stack to store operators. When the priority of the operator on top of the stack is higher or equal to that of the incoming operator, pop the operator in stack out. If the expression includes parentheses, follow the steps below: ’ ( ‘ has the highest priority, always push to stack . Once pushed, ‘ ( ‘ get lowest priority. Pop the operators in stack once you see the matched ‘ ) ‘. That is, ’ ( ‘ never pops other operators and never gets popped unless seeing a ‘ ) ‘ Example A + B * C A * (B + C) * D Infix to Prefix Steps Reverse the infix expression. Apply a modified infix to postfix algorithm on reversed input.(But do not pop the operator out if its priority is equal to the incoming operator.) Reverse the output expression. Example 1 + ( 3 * 4 – 5 ) / 6 * 7             The result is + 1 * / - * 3 4 5 6 7 . Postfix to Infix Rules Because the order of operands does not change , we can push every visting operand into stack directly. Store the last operator for each composite operand in the stack. The timing of adding ‘ () ‘: For the first operand, if the priority of the old operator is lower than the new operator, add ‘ () ‘. For the second operand, if the priority of the old operator is lower than or it is equal to that of the incoming operator which is either ’ / ‘ or ’ - ‘, add ‘ () ‘ Example 5 3 6 2 - + - 5 3 - 2 3 * /             The result is + 1 * / - * 3 4 5 6 7 . Postfix to Prefix Rules From left to right. If the incoming token is an operand , push it to stack. If the incoming token is an operator , pop the top two stack and concatenate them into {operand, operator2, operator1}. Example 3 4 * 5 – 6 / 7 *             The result is * / - * 3 4 5 6 7. Prefix to Infix Steps Reverse the prefix expression. Apply a modified postfix to infix algorithm on reversed input. Reverse the output expression. Example */ - * 3 4 5 6 7 Prefix to Postfix Steps Reverse the prefix expression. If the incoming token is an operand , push it to stack. If the incoming token is an operator , pop the top two stack and concatenate them into {operator1, operator2, operand}. Example */ - * 3 4 5 6 7             The result is 3 4 * 5 - 6 / 7 *." }, { "title": "Time Complexity", "url": "/posts/time-complexity/", "categories": "Code, Others, Time Complexity, Data Structure", "tags": "time complexity, data structure", "date": "2022-09-17 18:05:00 +0800", "snippet": "Big-O (O) 定義 f(n) = O(g(n)) iff there exists c, n0 &gt; 0 such that f(n)\\(\\le\\) c \\(\\cdot\\) g(n) for all n \\(\\ge\\) n0 意義 只需要找到 n0 和常數c使得所有符合n\\(\\ge\\) n0 的整數滿足f(n) \\(\\le\\) c \\(\\cdot\\) g(n)，則f(n) = O(g(n))成立。例子 3n+2 = O(n) 當 c=4, n0 = 2 時，3n+2 \\(\\le\\) 4n for all n \\(\\ge\\) 2 100n+6 = O(n) 當 c=101, n0 = 6 時，100n+6 \\(\\le\\) 101n for all n \\(\\ge\\) 6 10n2+4n+2 = O(n2) 當 c=11, n0 = 5 時，10n2+4n+2 \\(\\le\\) 11n2 for all n \\(\\ge\\) 5 特性 f(n) = O(g(n)) 代表 O(g(n)) 為 f(n) 的upper bound，因此 n = O(n) = O(n2.5) = O(n3) = O(nn)。一般會讓 g(n) 的值愈小愈好。 Big-O常用於取得一個程式的 worst-case running time。Big-Omega(\\(\\Omega\\)) 定義 f(n) = \\(\\Omega\\)(g(n)) iff there exists c, n0 &gt; 0 such that f(n)\\(\\ge\\) c \\(\\cdot\\) g(n) for all n \\(\\ge\\) n0 意義 只需要找到 n0 和常數c使得所有符合n\\(\\ge\\) n0 的整數滿足f(n) \\(\\ge\\) c \\(\\cdot\\) g(n)，則f(n) = \\(\\Omega\\)(g(n))成立。例子 3n+2 = \\(\\Omega\\)(n) 當 c=3, n0 = 1 時，3n+2 \\(\\ge\\) 3n for all n \\(\\ge\\) 1 100n+6 = \\(\\Omega\\)(n) 當 c=100, n0 = 1 時，100n+6 \\(\\ge\\) 100n for all n \\(\\ge\\) 1 10n2+4n+2 = \\(\\Omega\\)(n2) 當 c=1, n0 = 1 時，10n2+4n+2 \\(\\ge\\) n2 for all n \\(\\ge\\) 1 特性 f(n) = \\(\\Omega\\)(g(n)) 代表 \\(\\Omega\\)(g(n)) 為 f(n) lower bound。 \\(\\Omega\\) 常用於取得一個程式的 best-case running time。Big-Theta(\\(\\theta\\)) 定義 f(n) = \\(\\theta\\)(g(n)) iff f(n) = O(g(n)) and f(n) = \\(\\Omega\\)(g(n))。 意義 比 Big-O 和 Big-\\(\\Omega\\) 精確。例子 3n+2 = \\(\\theta\\)(n) 100n+6 = \\(\\theta\\)(n) 10n2+4n+2 = \\(\\theta\\)(n2)特性 f(n) = \\(\\theta\\)(g(n)) 代表 \\(\\theta\\)(g(n)) 為 f(n) tight bound。 \\(\\theta\\) 常用於取得一個程式的 average-case running time。" }, { "title": "CSES Apple Division", "url": "/posts/cses-Apple-Division/", "categories": "Code, CSES", "tags": "cses, dfs", "date": "2022-09-15 11:40:00 +0800", "snippet": "Problem Link作法DFSCode#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;ll n, sum;vector&lt;ll&gt; apples;ll dfs(ll pos, ll cur){ if(pos == n){ return abs(sum - 2 * cur); } ll ret = LLONG_MAX; for(int i=pos; i&lt;n; i++){ ret = min(ret, dfs(i + 1, cur + apples[i])); } return ret;}int main(){ cin &gt;&gt; n; apples.resize(n); for(ll i=0; i&lt;n; i++){ cin &gt;&gt; apples[i]; sum += apples[i]; } cout &lt;&lt; dfs(0, 0);}" }, { "title": "CSES Removal Game", "url": "/posts/cses-removal-game/", "categories": "Code, CSES", "tags": "cses, dp", "date": "2022-09-13 00:20:00 +0800", "snippet": "Problem Link作法DPCode#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;vector&lt;ll&gt; score(5005);vector&lt;vector&lt;ll&gt;&gt; dp(5005, vector&lt;ll&gt;(5005));vector&lt;vector&lt;bool&gt;&gt; seen(5005, vector&lt;bool&gt;(5005));ll f(int l, int r){ if(l == r) return score[r] - score[l-1]; if(seen[l][r]) return dp[l][r]; seen[l][r] = true; dp[l][r] = score[r] - score[l-1] - min(f(l+1, r), f(l, r-1)); return dp[l][r];}int main(){ int n; cin &gt;&gt; n; for(int i=1; i&lt;=n; i++){ cin &gt;&gt; score[i]; score[i] += score[i-1]; } cout &lt;&lt; f(1, n); return 0;}" }, { "title": "CSES Money Sums", "url": "/posts/cses-money-sums/", "categories": "Code, CSES", "tags": "cses, dp", "date": "2022-09-11 22:19:00 +0800", "snippet": "Problem Link作法 set bitsetCode1#include &lt;bits/stdc++.h&gt;using namespace std;set&lt;int&gt; s;int main(){ int n; cin &gt;&gt; n; for(int i=0; i&lt;n; i++){ int x; cin &gt;&gt; x; vector&lt;int&gt; tmp; for(auto&amp; i:s) tmp.emplace_back(i + x); for(auto&amp; i:tmp) s.emplace(i); s.emplace(x); } cout &lt;&lt; s.size() &lt;&lt; '\\n'; for(auto&amp; i:s) cout &lt;&lt; i &lt;&lt; ' '; return 0;}Code2#include &lt;bits/stdc++.h&gt;using namespace std;bitset&lt;1000005&gt; bs;int main(){ int n, x; cin &gt;&gt; n; bs[0] = 1; while(n--){ cin &gt;&gt; x; bs |= (bs &lt;&lt; x); } cout &lt;&lt; bs.count()-1 &lt;&lt; '\\n'; for(int i=1; i&lt;=1000000; i++){ if(bs[i]) cout &lt;&lt; i &lt;&lt; ' '; } return 0;}" }, { "title": "CSES Rectangle Cutting", "url": "/posts/cses-rectangle-cutting/", "categories": "Code, CSES", "tags": "cses, dp", "date": "2022-09-11 21:41:00 +0800", "snippet": "Problem Link作法DPCode#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;vector&lt;int&gt;&gt; dp(505, vector&lt;int&gt;(505, INT_MAX));int main(){ int a, b; cin &gt;&gt; a &gt;&gt; b; for(int i=1; i&lt;=a; i++){ for(int j=1; j&lt;=b; j++){ if(i == j){ dp[i][j] = 0; continue; } for(int k=1; k&lt;i; k++){ dp[i][j] = min(dp[i][j], dp[i-k][j] + dp[k][j] + 1); } for(int k=1; k&lt;j; k++){ dp[i][j] = min(dp[i][j], dp[i][j-k] + dp[i][k] + 1); } } } cout &lt;&lt; dp[a][b]; return 0;}" }, { "title": "CSES Edit Distance", "url": "/posts/cses-edit-distance/", "categories": "Code, CSES", "tags": "cses, dp", "date": "2022-09-11 20:58:00 +0800", "snippet": "Problem Link作法DPCode#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;vector&lt;int&gt;&gt; dp(5005, vector&lt;int&gt;(5005));int main(){ string s, t; cin &gt;&gt; s &gt;&gt; t; for(int i=1; i&lt;=5000; i++){ dp[i][0] = dp[0][i] = i; } for(int i=1; i&lt;=s.size(); i++){ for(int j=1; j&lt;=t.size(); j++){ if(s[i-1] == t[j-1]) dp[i][j] = dp[i-1][j-1]; else dp[i][j] = min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1])) + 1; } } cout &lt;&lt; dp[s.size()][t.size()]; return 0;}" }, { "title": "CSES Counting Towers", "url": "/posts/cses-counting-towers/", "categories": "Code, CSES", "tags": "cses, dp", "date": "2022-09-11 18:44:00 +0800", "snippet": "Problem Link作法DPCode#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const ll M = 1e9+7;vector&lt;vector&lt;ll&gt;&gt; dp(1000005, vector&lt;ll&gt;(2));int main(){ dp[1][0] = dp[1][1] = 1; for(int i=2; i&lt;=1000000; i++){ dp[i][0] = (dp[i-1][0]*2 + dp[i-1][1]) % M; dp[i][1] = (dp[i-1][0] + dp[i-1][1]*4) % M; } int t; cin &gt;&gt; t; while(t--){ int n; cin &gt;&gt; n; cout &lt;&lt; (dp[n][0] + dp[n][1]) % M &lt;&lt; '\\n'; } return 0;}" }, { "title": "CSES Array Description", "url": "/posts/cses-array-description/", "categories": "Code, CSES", "tags": "cses, dp", "date": "2022-09-11 18:16:00 +0800", "snippet": "Problem Link作法DPCode#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const ll M = 1e9+7;vector&lt;vector&lt;ll&gt;&gt; dp(100005, vector&lt;ll&gt;(105));int main(){ int n, m, x; cin &gt;&gt; n &gt;&gt; m &gt;&gt; x; if(x == 0){ for(int i=1; i&lt;=m; i++) dp[1][i]++; }else dp[1][x]++; for(int i=2; i&lt;=n; i++){ cin &gt;&gt; x; if(x == 0){ for(int j=1; j&lt;=m; j++) dp[i][j] = (dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j+1]) % M; }else dp[i][x] = (dp[i-1][x] + dp[i-1][x-1] + dp[i-1][x+1]) % M; } ll res = 0; for(int i=1; i&lt;=m; i++) res += dp[n][i]; cout &lt;&lt; res % M; return 0;}" }, { "title": "CSES Book Shop", "url": "/posts/cses-book-shop/", "categories": "Code, CSES", "tags": "cses, dp", "date": "2022-09-11 13:31:00 +0800", "snippet": "Problem Link作法DPCode#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;vector&lt;int&gt;&gt; dp(1005, vector&lt;int&gt;(100005));vector&lt;pair&lt;int, int&gt;&gt; books(100005);int main(){ int n, x; cin &gt;&gt; n &gt;&gt; x; for(int i=1; i&lt;=n; i++){ cin &gt;&gt; books[i].first; } for(int i=1; i&lt;=n; i++){ cin &gt;&gt; books[i].second; } for(int i=1; i&lt;=n; i++){ for(int j=0; j&lt;=x; j++){ dp[i][j] = dp[i-1][j]; if(j - books[i].first &gt;= 0) dp[i][j] = max(dp[i][j], dp[i-1][j-books[i].first] + books[i].second); } } cout &lt;&lt; dp[n][x]; return 0;}" }, { "title": "CSES Grid Paths", "url": "/posts/cses-grid-paths/", "categories": "Code, CSES", "tags": "cses, dp", "date": "2022-09-11 13:06:00 +0800", "snippet": "Problem Link作法DPCode#include &lt;bits/stdc++.h&gt;using namespace std;const int M = 1e9+7;vector&lt;vector&lt;int&gt;&gt; dp(1005, vector&lt;int&gt;(1005));int main(){ int n; cin &gt;&gt; n; char c; dp[0][1] = 1; for(int i=1; i&lt;=n; i++){ for(int j=1; j&lt;=n; j++){ cin &gt;&gt; c; if(c == '.') dp[i][j] = (dp[i-1][j] + dp[i][j-1]) % M; } } cout &lt;&lt; dp[n][n]; return 0;}" }, { "title": "CSES Removing Digits", "url": "/posts/cses-removing-digits/", "categories": "Code, CSES", "tags": "cses, dp", "date": "2022-09-11 12:53:00 +0800", "snippet": "Problem Link作法DPCode#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; dp(1000006, INT_MAX);bool valid(int v, int k){ while(v){ if(v % 10 == k) return true; v /= 10; } return false;}int main(){ int n; cin &gt;&gt; n; dp[0] = 0; for(int i=0; i&lt;=n; i++){ for(int j=1; j&lt;=9; j++){ if(i - j &gt;= 0 &amp;&amp; valid(i, j)) dp[i] = min(dp[i], dp[i-j]+1); } } cout &lt;&lt; dp[n]; return 0;}" }, { "title": "CSES Coin Combinations II", "url": "/posts/cses-coin-combinations-II/", "categories": "Code, CSES", "tags": "cses, dp", "date": "2022-09-11 12:42:00 +0800", "snippet": "Problem Link作法DPCode#include &lt;bits/stdc++.h&gt;const int M = 1e9+7;using namespace std;vector&lt;int&gt; dp(1000005), coins(105);int main(){ int n, x; cin &gt;&gt; n &gt;&gt; x; for(int i=0; i&lt;n; i++){ cin &gt;&gt; coins[i]; } dp[0] = 1; for(int i=0; i&lt;n; i++){ for(int j=1; j&lt;=x; j++){ if(j - coins[i] &gt;= 0) dp[j] = (dp[j] + dp[j - coins[i]]) % M; } } cout &lt;&lt; dp[x]; return 0;}" }, { "title": "CSES Coin Combinations I", "url": "/posts/cses-coin-combinations-I/", "categories": "Code, CSES", "tags": "cses, dp", "date": "2022-09-11 12:37:00 +0800", "snippet": "Problem Link作法DPCode#include &lt;bits/stdc++.h&gt;const int M = 1e9+7;using namespace std;vector&lt;int&gt; dp(1000005), coins(105);int main(){ int n, x; cin &gt;&gt; n &gt;&gt; x; for(int i=0; i&lt;n; i++){ cin &gt;&gt; coins[i]; } dp[0] = 1; for(int i=1; i&lt;=x; i++){ for(int j=0; j&lt;n; j++){ if(i - coins[j] &gt;= 0) dp[i] = (dp[i] + dp[i - coins[j]]) % M; } } cout &lt;&lt; dp[x]; return 0;}" }, { "title": "CSES Minimizing Coins", "url": "/posts/cses-minimizing-coins/", "categories": "Code, CSES", "tags": "cses, dp", "date": "2022-09-11 12:25:00 +0800", "snippet": "Problem Link作法DPCode#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; dp(1000005, INT_MAX), coins(105);int main(){ int n, x; cin &gt;&gt; n &gt;&gt; x; for(int i=0; i&lt;n; i++){ cin &gt;&gt; coins[i]; } dp[0] = 0; for(int i=1; i&lt;=x; i++){ for(int j=0; j&lt;n; j++){ if(i - coins[j] &gt;= 0 &amp;&amp; dp[i-coins[j]] != INT_MAX) dp[i] = min(dp[i], dp[i-coins[j]]+1); } } if(dp[x] == INT_MAX) cout &lt;&lt; -1; else cout &lt;&lt; dp[x]; return 0;}" }, { "title": "CSES Dice Combinations", "url": "/posts/cses-dice-combinations/", "categories": "Code, CSES", "tags": "cses, dp", "date": "2022-09-11 12:07:00 +0800", "snippet": "Problem Link作法DPCode#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const ll M = 1e9+7;vector&lt;ll&gt; dp(1000005);int main(){ int n; cin &gt;&gt; n; dp[0] = 1; for(int i=0; i&lt;=n; i++){ for(int j=1; j &lt;= 6; j++){ if(i-j &gt;= 0) dp[i] = (dp[i] + dp[i-j]) % M; } } cout &lt;&lt; dp[n]; return 0;}" }, { "title": "TIOJ 1226 . H遊戲", "url": "/posts/tioj-1226/", "categories": "Code, TIOJ", "tags": "tioj, topological sort", "date": "2022-09-01 16:50:00 +0800", "snippet": "Problem Link作法拓撲排序，並以dp記錄能達到某點的路徑的數量。假設從 a 點到 b 點的權重為 10，且從 0 點到 a 點有 3 種路徑，則 b 點的總花費 = a 點的總花費 + 10(權重) * 3(路徑數)。Code#include &lt;bits/stdc++.h&gt;#define M 32768#define ll long longusing namespace std;int main(){ ios_base::sync_with_stdio(0); cin.tie(0); ll t; cin &gt;&gt; t; for(ll g=1; g&lt;=t; g++){ vector&lt;vector&lt;pair&lt;ll, ll&gt;&gt;&gt; e(1005); vector&lt;string&gt; name(105); vector&lt;ll&gt; val(1005), task(1005), dp(1005); ll N, V, E; cin &gt;&gt; N &gt;&gt; V &gt;&gt; E; for(ll i=0; i&lt;N; i++){ cin &gt;&gt; name[i]; } while(E--){ ll from, to, w; cin &gt;&gt; from &gt;&gt; to &gt;&gt; w; e[from].emplace_back(to, w%M); task[to]++; } queue&lt;ll&gt; q; q.emplace(0); dp[0] = 1; while(!q.empty()){ ll cur = q.front(); q.pop(); for(auto&amp; i:e[cur]){ val[i.first] += (val[cur] + i.second*dp[cur])%M; dp[i.first] += dp[cur]; task[i.first]--; if(!task[i.first]) q.emplace(i.first); } } cout &lt;&lt; \"Game #\" &lt;&lt; g &lt;&lt; '\\n'; for(ll i=0; i&lt;N; i++){ cout &lt;&lt; name[i] &lt;&lt; \": \" &lt;&lt; val[i+1]%M &lt;&lt; '\\n'; } } return 0;}" }, { "title": "TIOJ 1092. A.跳格子遊戲", "url": "/posts/tioj-1092/", "categories": "Code, TIOJ", "tags": "tioj", "date": "2022-09-01 16:41:00 +0800", "snippet": "Problem Link作法從終點開始往回推。考慮某圓圈的所有下一步，若存在某一步使的玩家能達到必勝的點，則該圓圈必敗，因為對方一定會往必勝的圓圈走。反之，如果所有下一步皆為必敗的點，則該圓圈必勝，因為不管怎樣對方都會輸。Code#include &lt;bits/stdc++.h&gt;using namespace std; vector&lt;vector&lt;int&gt;&gt; e(10005);int out[10005], state[10005];int N, E;string name;int main(){ ios_base::sync_with_stdio(0); cin.tie(0); // 1 = win, 0 = lose while(cin &gt;&gt; N &gt;&gt; E, (N || E)){ for(auto&amp; v:e) v.clear(); memset(out, 0, sizeof(out)); memset(state, 0, sizeof(state)); while(E--){ int from, to; cin &gt;&gt; from &gt;&gt; to; e[to].emplace_back(from); out[from]++; } cin &gt;&gt; name; state[N] = 1; // 終點 queue&lt;int&gt; q; q.emplace(N); while(!q.empty()){ int cur = q.front(); q.pop(); for(int&amp; i:e[cur]){ if(state[cur] == 1){ out[i] = state[i] = 0; q.emplace(i); }else{ out[i]--; if(out[i] == 0){ q.emplace(i); state[i] = 1; } } } } if(state[1] == 1){ cout &lt;&lt; name &lt;&lt; '\\n'; }else if(name == \"Moumou\"){ cout &lt;&lt; \"Mimi\\n\"; }else{ cout &lt;&lt; \"Moumou\\n\"; } } return 0;}" }, { "title": "CSES Salary Queries", "url": "/posts/cses-salary-queries/", "categories": "Code, CSES", "tags": "cses, segment tree", "date": "2022-08-23 21:11:00 +0800", "snippet": "Problem Link作法 離散化(discretization) + 線段樹(segment tree) 離散化(discretization) + BIT(binary indexed tree) Code1#include &lt;bits/stdc++.h&gt;#define io ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);using namespace std;vector&lt;int&gt; v(2e5+10), t, s(1e7+10);vector&lt;vector&lt;int&gt;&gt; op;int query(int id, int l, int r, int ql, int qr){ if(qr == 0 || ql &gt; r || qr &lt; l) return 0; if(ql &lt;= l &amp;&amp; qr &gt;= r) return s[id]; int m = (l+r)/2; return query(id*2, l, m, ql, qr) + query(id*2+1, m+1, r, ql, qr);}void update(int id, int l, int r, int v, int target_id){ if(l == r){ s[id] += v; return; } int m = (l+r)/2; m &gt;= target_id ? update(id*2, l, m, v, target_id) : update(id*2+1, m+1, r, v, target_id); s[id] = s[id*2] + s[id*2+1];}int relabel(int x){ return lower_bound(t.begin(), t.end(), x) - t.begin() + 1;}int relabel_upper(int x){ return upper_bound(t.begin(), t.end(), x) - t.begin();}int main(){ io int n, q; cin &gt;&gt; n &gt;&gt; q; for(int i=1; i&lt;=n; i++){ cin &gt;&gt; v[i]; t.emplace_back(v[i]); } for(int i=1; i&lt;=q; i++){ char c; int a, b; cin &gt;&gt; c &gt;&gt; a &gt;&gt; b; if(c == '!') t.emplace_back(b); op.emplace_back(vector&lt;int&gt;{c == '!', a, b}); } sort(t.begin(), t.end()); t.erase(unique(t.begin(), t.end()), t.end()); for(int i=1; i&lt;=n; i++){ update(1, 1, t.size(), 1, relabel(v[i])); } for(int i=0; i&lt;q; i++){ if(op[i][0] == 1){ update(1, 1, t.size(), -1, relabel(v[op[i][1]])); update(1, 1, t.size(), 1, relabel(op[i][2])); v[op[i][1]] = op[i][2]; }else{ cout &lt;&lt; query(1, 1, t.size(), 1, relabel_upper(op[i][2])) - query(1, 1, t.size(), 1, relabel(op[i][1])-1) &lt;&lt; '\\n'; } } return 0;}Code2#include &lt;bits/stdc++.h&gt;#define io ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);using namespace std;vector&lt;int&gt; v(2e5+10), t, BIT(4e5+10);vector&lt;vector&lt;int&gt;&gt; op;void update(int x, int d){ x = lower_bound(t.begin(), t.end(), x) - t.begin() + 1; while(x &lt;= t.size()){ BIT[x] += d; x += x &amp; (-x); }}int find(int x){ int ret = 0; while(x &gt; 0){ ret += BIT[x]; x -= x &amp; (-x); } return ret;}int query(int l, int r){ int a = lower_bound(t.begin(), t.end(), l) - t.begin(); int b = upper_bound(t.begin(), t.end(), r) - t.begin(); return find(b) - find(a);}int main(){ io int n, q; cin &gt;&gt; n &gt;&gt; q; for(int i=1; i&lt;=n; i++){ cin &gt;&gt; v[i]; t.emplace_back(v[i]); } for(int i=1; i&lt;=q; i++){ char c; int a, b; cin &gt;&gt; c &gt;&gt; a &gt;&gt; b; if(c == '!') t.emplace_back(b); op.emplace_back(vector&lt;int&gt;{c == '!', a, b}); } sort(t.begin(), t.end()); t.erase(unique(t.begin(), t.end()), t.end()); for(int i=1; i&lt;=n; i++){ update(v[i], 1); } for(int i=0; i&lt;q; i++){ if(op[i][0] == 1){ update(v[op[i][1]], -1); update(op[i][2], 1); v[op[i][1]] = op[i][2]; }else{ cout &lt;&lt; query(op[i][1], op[i][2]) &lt;&lt; '\\n'; } } return 0;}" }, { "title": "LeetCode-128. Longest Consecutive Sequence", "url": "/posts/leetcode-128/", "categories": "Code, LeetCode", "tags": "leetcode", "date": "2022-08-18 15:20:00 +0800", "snippet": "Problem Link題目敘述給你一組未排序的陣列，輸出最長連續數字的序列長度。(必須在O(n)時間複雜度內)Example 1:Input: nums = [100,4,200,1,3,2]Output: 4Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.作法我們可以將所有數字存在hash裡，藉此快速判斷某數字是否存在。接著遍歷所有數字，快速判斷該數字是否為連續數列的第一項，如果是，就繼續判斷該數字的下一項、下兩項、下三項…是否存在，同時記錄它的最長長度。Codeclass Solution {public: int longestConsecutive(vector&lt;int&gt;&amp; nums) { unordered_set&lt;int&gt; st; for(int&amp; num:nums) st.emplace(num); int ret = 0; for(auto&amp; num:st){ if(!st.count(num-1)){ int len = 1; while(st.count(num+len)) len++; ret = max(ret, len); } } return ret; }};" }, { "title": "CSES Fibonacci Numbers", "url": "/posts/cses-fibonacci-numbers/", "categories": "Code, CSES", "tags": "cses, exponentiation by squaring", "date": "2022-08-16 15:52:00 +0800", "snippet": "Problem Link作法矩陣 + 快速冪Code#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const ll M = 1e9+7;vector&lt;ll&gt; matrix_cal(vector&lt;ll&gt; a, vector&lt;ll&gt;b){ vector&lt;ll&gt; ret(4); ret[0] = (a[0]*b[0] + a[1]*b[2])%M; ret[1] = (a[0]*b[1] + a[1]*b[3])%M; ret[2] = (a[2]*b[0] + a[3]*b[2])%M; ret[3] = (a[2]*b[1] + a[3]*b[3])%M; return ret;}vector&lt;ll&gt; binpow(ll n){ if(n == -1) return vector&lt;ll&gt;{0}; if(n == 0 || n == 1) return vector&lt;ll&gt;{1, 1, 1, 0}; vector&lt;ll&gt; hf = binpow(n/2); return n % 2 ? matrix_cal(matrix_cal(hf, hf), vector&lt;ll&gt;{1, 1, 1, 0}) : matrix_cal(hf, hf);}int main(){ ll n; cin &gt;&gt; n; cout &lt;&lt; binpow(n-1)[0] &lt;&lt; '\\n'; return 0;}" }, { "title": "UVA-10917 Walk Through the Forest", "url": "/posts/uva-10917/", "categories": "Code, UVA", "tags": "uva, dijkstra, dp", "date": "2022-08-16 15:42:00 +0800", "snippet": "Problem Link作法Dijkstra + DPCode#include &lt;bits/stdc++.h&gt;using namespace std;struct node{ int id, cost; node(){} node(int i, int c):id(i),cost(c){} bool operator&lt;(const node&amp; a)const{ return cost &gt; a.cost; }};vector&lt;vector&lt;int&gt;&gt; neighbors;vector&lt;bool&gt; seen;vector&lt;int&gt; shortest, dp;int path[1050][1050];void init(int N){ dp.clear(); dp.resize(N+1, -1); neighbors.clear(); neighbors.resize(N+1); seen.clear(); seen.resize(N+1); shortest.clear(); shortest.resize(N+1, INT_MAX); shortest[2] = 0;}int dfs(int id){ if(id == 2) return 1; if(~dp[id]) return dp[id]; int s = 0; for(int&amp; i:neighbors[id]){ if(shortest[i] &lt; shortest[id]) s += dfs(i); } dp[id] = s; return s;}int main(){ ios_base::sync_with_stdio(0); cin.tie(0); int N, M; while(cin &gt;&gt; N, N){ cin &gt;&gt; M; init(N); while(M--){ int a, b, d; cin &gt;&gt; a &gt;&gt; b &gt;&gt; d; neighbors[a].emplace_back(b); neighbors[b].emplace_back(a); path[a][b] = path[b][a] = d; } priority_queue&lt;node&gt; pq; pq.emplace(node(2, 0)); while(!pq.empty()){ node cur = pq.top(); pq.pop(); if(seen[cur.id]) continue; else seen[cur.id] = true; for(int&amp; i:neighbors[cur.id]){ if(!seen[i]){ if(cur.cost + path[i][cur.id] &lt; shortest[i]){ shortest[i] = cur.cost + path[i][cur.id]; pq.emplace(node(i, shortest[i])); } } } } cout &lt;&lt; dfs(1) &lt;&lt; '\\n'; } return 0;}" }, { "title": "ZeroJudge-c152 學語法的前置作業(?", "url": "/posts/zerojudge-c152/", "categories": "Code, ZeroJudge", "tags": "zerojudge, dijkstra", "date": "2022-08-16 11:04:00 +0800", "snippet": "Problem Link作法兩次 DijkstraCode#include &lt;bits/stdc++.h&gt;using namespace std;struct state{ state(){} state(int i, float c): id(i), cost(c){} state(int i, float c, float d): id(i), cost(c), dis(d){} int id; float cost, dis; bool operator&lt;(const state&amp; n) const{ return cost &gt;= n.cost; }};struct node{ node(){} node(int i, int d, float t):id(i), dis(d), time(t){} int id, dis; float time;};int main(){ ios_base::sync_with_stdio(0); cin.tie(0); int t; cin &gt;&gt; t; while(t--){ int N, M, A, B; cin &gt;&gt; N &gt;&gt; M &gt;&gt; A &gt;&gt; B; vector&lt;vector&lt;node&gt;&gt; neighbors(N+1); vector&lt;bool&gt; seen(N+1); while(M--){ int a, b, d, v; cin &gt;&gt; a &gt;&gt; b &gt;&gt; d &gt;&gt; v; neighbors[a].emplace_back(node(b, d, d/(float)v)); neighbors[b].emplace_back(node(a, d, d/(float)v)); } priority_queue&lt;state&gt; pq; // first dijkstra pq.emplace(state(A, 0)); while(!pq.empty()){ state cur = pq.top(); pq.pop(); if(seen[cur.id]) continue; if(cur.id == B){ cout &lt;&lt; (int)cur.cost &lt;&lt; ' '; break; } seen[cur.id] = true; for(node&amp; i:neighbors[cur.id]){ if(!seen[i.id]){ pq.emplace(state(i.id, cur.cost + i.dis)); } } } // init while(!pq.empty()) pq.pop(); for(int i=0; i&lt;=N; i++) seen[i] = false; // second dijkstra pq.emplace(state(A, 0, 0)); while(!pq.empty()){ state cur = pq.top(); pq.pop(); if(seen[cur.id]) continue; if(cur.id == B){ cout &lt;&lt; (int)cur.dis &lt;&lt; '\\n'; break; } seen[cur.id] = true; for(node&amp; i:neighbors[cur.id]){ if(!seen[i.id]){ pq.emplace(state(i.id, cur.cost + i.time, cur.dis + i.dis)); } } } } return 0;}" }, { "title": "ZeroJudge-a007 判斷質數", "url": "/posts/zerojudge-a007/", "categories": "Code, ZeroJudge", "tags": "zerojudge", "date": "2022-08-15 23:01:00 +0800", "snippet": "Problem Link題目敘述輸入多筆測資，每筆測資包含一個整數 x (2 ≦ x ≦ 2147483647)，判斷 x 是否為質數。作法很明顯的，這道題目必須建立質數表來減少判斷的時間，這邊選擇使用埃式篩法。然而，由於 x 的值最多可達 2147483647，直接開陣列判斷的話會炸開。我們可以從簡單的問題著手: 如何判斷一個數是質數?對於13而言，只需判斷 ≦ \\(\\sqrt{13}\\) 的質數就好，如果前半部的數都無法整除 13，後半部的部分也不可能整除。同理，要判斷 x = 2147483647 是否為質數，只需要將 x 除以 ≦ \\(\\sqrt{x}\\) 的質數來判斷就好。\\(\\sqrt{2147483647}\\) 的整數部分為 46340，因此質數表建到 46340 即可。Code#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; v;vector&lt;bool&gt; is_prime(46341, true);int main(){ ios_base::sync_with_stdio(0); cin.tie(0); is_prime[1] = false; for(int i=2; i&lt;=46340; i++){ // 建表 if(!is_prime[i]) continue; else v.emplace_back(i); // 小於46341的質數 for(int j = i*i; j&lt;= 46340; j+=i){ is_prime[j] = false; } } int n; while(cin &gt;&gt; n){ if(n &gt; 46340){ bool flag = false; for(int&amp; i:v){ if(n % i == 0){ flag = true; break; } } if(flag) cout &lt;&lt; \"非質數\\n\"; else cout &lt;&lt; \"質數\\n\"; }else{ if(is_prime[n]) cout &lt;&lt; \"質數\\n\"; else cout &lt;&lt; \"非質數\\n\"; } } return 0;}" } ]
