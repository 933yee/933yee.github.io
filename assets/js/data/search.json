[ { "title": "UVA-11463 Commandos", "url": "/posts/uva-11463/", "categories": "Code, UVA", "tags": "uva, floyd-warshall", "date": "2022-11-17 01:27:00 +0800", "snippet": "Problem Linkä½œæ³•Floyd-WarshallCode#include &lt;bits/stdc++.h&gt;using namespace std;int t, n, m, u, v, s, d;int dis[105][105];int main(){ cin &gt;&gt; t; for(int c = 1; c &lt;= t; c++){ cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; 105; i++) for(int j = 0; j &lt; 105; j++) dis[i][j] = (i == j) ? 0 : 105; for(int i = 0; i &lt; m; i++){ cin &gt;&gt; u &gt;&gt; v; dis[u][v] = dis[v][u] = 1; } for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; n; j++) for(int k = 0; k &lt; n; k++) if(dis[j][i] + dis[i][k] &lt; dis[j][k]) dis[j][k] = dis[j][i] + dis[i][k]; cin &gt;&gt; s &gt;&gt; d; int mx = -1; for(int i = 0; i &lt; n; i++) mx = max(mx, dis[s][i] + dis[i][d]); cout &lt;&lt; \"Case \" &lt;&lt; c &lt;&lt; \": \" &lt;&lt; mx &lt;&lt; '\\n'; }}" }, { "title": "UVA-558 Wormholes", "url": "/posts/uva-558/", "categories": "Code, UVA", "tags": "uva, bellman-ford", "date": "2022-11-17 00:47:00 +0800", "snippet": "Problem Linkä½œæ³•Bellman-FordCode#include &lt;bits/stdc++.h&gt;using namespace std;int t, n, m, u, v, w;vector&lt;tuple&lt;int, int, int&gt;&gt; edges;vector&lt;int&gt; dist;int main(){ cin &gt;&gt; t; while(t--){ cin &gt;&gt; n &gt;&gt; m; edges.clear(); dist.clear(); dist.resize(n, INT_MAX/2); for(int i=0; i&lt;m; i++){ cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; edges.emplace_back(u, v, w); } dist[0] = 0; for(int i=0; i&lt;n; i++){ bool update = false; for(auto j: edges){ tie(u, v, w) = j; if(dist[v] &gt; dist[u] + w){ dist[v] = dist[u] + w; update = true; } } if(!update){ cout &lt;&lt; \"not possible\\n\"; break; } if(i == n-1){ cout &lt;&lt; \"possible\\n\"; break; } } }}" }, { "title": "Trees", "url": "/posts/trees/", "categories": "Code, Others, Trees, Data Structure", "tags": "trees, data structure", "date": "2022-10-22 19:49:00 +0800", "snippet": "Left Child-Right Sibling Property Each node has exactly two link fields Left link(child): points to leftmost child node. Right link(sibling): points to closest sibling node. Rotate clockwise 45Â° Special Binary Tree Full binary tree A binary tree of depth k which has 2k â€“ 1 nodes Complete binary tree All the levels of the tree are filled completely except the lowest level nodes which are filled from as left as possible. Traversal Preorder recursive void traversal_preorder_recursive(node* cur){ if(!cur) return; cout &lt;&lt; cur-&gt;data &lt;&lt; ' '; traversal_preorder_recursive(cur-&gt;left); traversal_preorder_recursive(cur-&gt;right); } iterative void traversal_preorder_non_recursive(node* root){ stack&lt;node*&gt; st; st.push(root); while(1){ if(st.empty()) break; node* current = st.top(); cout &lt;&lt; current-&gt;data &lt;&lt; ' '; st.pop(); if(current-&gt;right) st.push(current-&gt;right); if(current-&gt;left) st.push(current-&gt;left); } } Inorder recursive void traversal_inorder_recursive(node* cur){ if(!cur) return; traversal_inorder_recursive(cur-&gt;left); cout &lt;&lt; cur-&gt;data &lt;&lt; ' '; traversal_inorder_recursive(cur-&gt;right); } iterative void traversal_inorder_non_recursive(node* root){ stack&lt;node*&gt; st; node* current = root; while(1){ while(current){ st.push(current); current = current-&gt;left; } if(st.empty()) break; current = st.top(); cout &lt;&lt; current-&gt;data &lt;&lt; ' '; st.pop(); current = current-&gt;right; } } Postorder recursive void traversal_postorder_recursive(node* cur){ if(!cur) return; traversal_postorder_recursive(cur-&gt;left); traversal_postorder_recursive(cur-&gt;right); cout &lt;&lt; cur-&gt;data &lt;&lt; ' '; } iterative void traversal_postorder_non_recursive(node* root){ stack&lt;node*&gt; st; node* current = root; while(1){ while(current){ st.push(current); st.push(current); current = current-&gt;left; } if(st.empty()) break; current = st.top(); st.pop(); if(!st.empty() &amp;&amp; st.top() == current){ current = current-&gt;right; }else{ cout &lt;&lt; current-&gt;data &lt;&lt; ' '; current = nullptr; } } } Level-order void traversal_level_order(node* root){ queue&lt;node*&gt; q; q.push(root); while(!q.empty()){ node* current = q.front(); q.pop(); cout &lt;&lt; current-&gt;data &lt;&lt; ' '; if(current-&gt;left) q.push(current-&gt;left); if(current-&gt;right) q.push(current-&gt;right); } } Binary Search Tree Property Every element has a key and no two elements have the same key. The keys (if any) in the left subtree are smaller than the key in the root. The keys (if any) in the right subtree are larger than the key in the root. The left and right subtrees are also BST. Inorder traversal of a BST will result in a sorted list. Search an Element Start from root Compare the key with root â€™&lt;â€™ search the left subtree â€™&gt;â€™ search the right subtree Repeat step 2 until the key is found or a leaf is visited Search an Element by Rank To facilitate searching for rank-r element, we store the additional information, leftSize leftSize = 1 + # of nodes in left subtree If we are searching for the rank-r element, we perform: Set currentNode = root Consider 3 cases leftSize &gt; r: currentNode = left child; repeat (2) leftSize &lt; r: r = r â€“ leftSize; currentNode = right child, repeat (2) leftSize = r: bingo; break Example Insert First we search for the existence of the element. If the search is unsuccessful, then the element is inserted at the point the search terminates. Delete Steps: delete an element with key k Search for the key k If the search is successful, we have to deal three scenarios The element is a leaf node The element is a non-leaf node with one child The element is a non-leaf node with two children Min and Max element Min (Max) element is at the leftmost (rightmost) of the tree. Min or max are not always terminal nodes. Min or max has at most one child. Scenario 1 : The element is a leaf node The child field of parent node is set to NULL Dispose the node Scenario 2 : The element is a non-leaf node with one child Simply change the pointer from the parent node to the single-child node . Dispose the node Scenario 3 : The element is a non-leaf node with two children The deleted element is replaced by either the smallest element in right subtree the largest element in left subtree Delete the node and replace by: A leaf node \\(\\rightarrow\\) apply scenario 1 A non-leaf node with one child \\(\\rightarrow\\) apply scenario 2 Balanced The worst-case is caused by the lack of tree balance. Linked list How to Keep a Balanced BST ? AVL Trees Red-black Trees Splay Trees Self adjusting trees B-trees Multiway search trees AVL Trees A height-balanced binary search tree. Each node in an AVL tree stores the current node height for calculating the balance factor . Height-balanced &amp; Blance factor: An empty tree is height balanced. If ğ‘» is a non-empty binary tree with ğ‘»ğ‘³ and ğ‘»ğ‘¹ as its left and right subtrees respectively: Balance factor ğ‘ğ‘“(ğ‘») = â„ğ‘’ğ‘–ğ‘”â„ğ‘¡(ğ‘»ğ‘³) âˆ’ â„ğ‘’ğ‘–ğ‘”â„ğ‘¡(ğ‘»ğ‘¹) ğ‘» is height balanced iff: ğ‘»ğ‘³ and ğ‘»ğ‘¹ are height balanced. \\(\\vert\\) ğ‘ğ‘“(ğ‘») \\(\\vert\\) â‰¤ 1 Rebalancing BST insertion/deletion operation may cause imblance Steps Update the heights (balance factors) from the inserted/deleted node up to the root . Fix unbalanced situations using rotations. Unbalanced Situations There are 4 kinds of imbalanced situations: 2 outside cases: require single rotation (LL, RR) 2 inside cases: require double rotation (LR, RL) Forest Definition A forest is a set of n â‰¥ 0 disjoint trees Operations Transforming a forest to binary tree Apply left child-right sibling approach Convert each tree into binary tree Connect two binary trees, T1 and T2, by setting the rightChild of root(T1) to the root(T2) Forest traversals Assume we have a forest F and corresponding binary tree T, then Preorder (inorder) traversal of T is equivalent to visiting the nodes of F in forest preorder (inorder) Disjoint Sets Definition Assume a set S of n integers {0, 1, 2,â€¦, n-1} is divided into several subsets S1, S2, â€¦ , Sk and Si âˆ© Sj = Ñ„ for any i, j Ñ” { 1, â€¦ , k } and i â‰  j Operations Disjoint set union : Union(Si, Sj) Si = Si U Sj or Sj = Si U Sj Find the set containing element x : Find(x) Example Set S = { 0, 1, 2, 3, 4, 5 } Disjoint subsets S1 = { 0, 2, 3 } S2 = { 1 } S3 = { 4, 5 } Union(S1, S2) = { 0, 1, 2, 3 } Find(5) = 3 Array Representation Using a sequential mapping array where index represents set members and array value indicates set name Example S = { 0, 1, 2, 3, 4, 5 } with subsets S1 = { 0, 2, 3 }, S2 = { 1 } and S3 = { 4, 5 } Find(x) Complexity = O(1) Find(5) = S[5] = set 3 Find(3) = S[3] = set 1 Union(Si, Sj) Assume we always merge the 2nd set to 1st set , that is Si = Si U Sj Scan the array and set S[k] to i if S[k] == j S2 = Union(S2, S3) Time Complexity S = { 0, 1, 2, â€¦ , n-1 } S1 = { 0 }, S2 = { 1 }, S3 = { 2 }, â€¦ , Sn = { n-1 } Union Union(S2, S1), Union(S3, S2), â€¦, Union(Sn, Sn-1) (n-1)*O(n) = O(n2) Find Find(0), Find(1), â€¦, Find(n-1) n*O(1) = O(n) Total time complexity = O(n2) Tree Representation Use an array to store the tree. Identify the set by the root of the tree. Union(Si, Sj) Set the parent field of one of the root to the other root. S1 = Union(S1, S3) Time complexity : O(1) Find(x) Following the index starting at x and tracing the tree structure until reaching a node with parent value = itself Use the root to identify the set name Time Complexity S = { 0, 1, 2, â€¦ , n-1 } S1 = { 0 }, S2 = { 1 }, S3 = { 2 }, â€¦ , Sn = { n-1 } Union Union(S2, S1), Union(S3, S2), â€¦, Union(Sn, Sn-1) Followed by a sequence of Find Find(0), Find(1), â€¦, Find(n-1) Total time complexity = 1 + 2 + 3 + â€¦ + n = O(n2) Improved Union(Si, Sj) Do not always merge two sets into the first set Adopt a Weighting rule to union operation Si = Si U Sj, if \\(\\vert\\) Si \\(\\vert\\) â‰¥ \\(\\vert\\) Sj \\(\\vert\\) Sj = Si U Sj, if \\(\\vert\\) Si \\(\\vert\\) &lt; \\(\\vert\\) Sj \\(\\vert\\) That is, make small tree connect to bigger tree Example S = { 0, 1, 2, â€¦ , n-1 } S1 = { 0 }, S2 = { 1 }, S3 = { 2 }, â€¦ , Sn = { n-1 } Union(S1, S2), Union(S1, S3), Union(S1, S4) Let T be a tree with m nodes created by a sequence of weighting unions. The height of T is no greater than \\(\\lfloor\\) log2m \\(\\rfloor\\) + 1 . " }, { "title": "Expressions", "url": "/posts/expressions/", "categories": "Code, Others, Expressions, Data Structure", "tags": "expressions, data structure", "date": "2022-10-05 14:01:00 +0800", "snippet": "Infix Property Operator comes in-between the operands. Ambiguous. Need parentheses to make them unambiguous. Hard to evaluate using codes. Postfix Property Each operator appears after its operands. No need parentheses . Priority of operators is no longer relevant. Postfix notations can be used in intermediate code generation in compiler design. Easier to parse for a machine. Evaluation Step Making a left to right scan. Stacking operands. Evaluating operators. Push the result into stack. Example A B + C + push A push B (detecting an operator) pop two operands out and push the result after calculating them push C (detecting an operator) pop two operands out and push the result after calculating them Â Â Â Â Â Â Â Â Â Â Â Â The result is (A + B) + C .Prefix Property Each operator appears before its operands. No need parentheses . Priority of operators is no longer relevant. Easier to parse for a machine. Evaluation Step The same as evaluating postfix, but read from right to left Example / A * B C push C push B (detecting an operator) pop two operands out and push the result after calculating them push A (detecting an operator) pop two operands out and push the result after calculating them Â Â Â Â Â Â Â Â Â Â Â Â The result is A / (B * C) .Conversion Infix to Postfix Rules Because the order of operands does not change , we can just output every visting operand directly. Utilize stack to store operators. When the priority of the operator on top of the stack is higher or equal to that of the incoming operator, pop the operator in stack out. If the expression includes parentheses, follow the steps below: â€™ ( â€˜ has the highest priority, always push to stack . Once pushed, â€˜ ( â€˜ get lowest priority. Pop the operators in stack once you see the matched â€˜ ) â€˜. That is, â€™ ( â€˜ never pops other operators and never gets popped unless seeing a â€˜ ) â€˜ Example A + B * C A * (B + C) * D Infix to Prefix Steps Reverse the infix expression. Apply a modified infix to postfix algorithm on reversed input.(But do not pop the operator out if its priority is equal to the incoming operator.) Reverse the output expression. Example 1 + ( 3 * 4 â€“ 5 ) / 6 * 7 Â Â Â Â Â Â Â Â Â Â Â Â The result is + 1 * / - * 3 4 5 6 7 . Postfix to Infix Rules Because the order of operands does not change , we can push every visting operand into stack directly. Store the last operator for each composite operand in the stack. The timing of adding â€˜ () â€˜: For the first operand, if the priority of the old operator is lower than the new operator, add â€˜ () â€˜. For the second operand, if the priority of the old operator is lower than or it is equal to that of the incoming operator which is either â€™ / â€˜ or â€™ - â€˜, add â€˜ () â€˜ Example 5 3 6 2 - + - 5 3 - 2 3 * / Â Â Â Â Â Â Â Â Â Â Â Â The result is + 1 * / - * 3 4 5 6 7 . Postfix to Prefix Rules From left to right. If the incoming token is an operand , push it to stack. If the incoming token is an operator , pop the top two stack and concatenate them into {operand, operator2, operator1}. Example 3 4 * 5 â€“ 6 / 7 * Â Â Â Â Â Â Â Â Â Â Â Â The result is * / - * 3 4 5 6 7. Prefix to Infix Steps Reverse the prefix expression. Apply a modified postfix to infix algorithm on reversed input. Reverse the output expression. Example */ - * 3 4 5 6 7 Prefix to Postfix Steps Reverse the prefix expression. If the incoming token is an operand , push it to stack. If the incoming token is an operator , pop the top two stack and concatenate them into {operator1, operator2, operand}. Example */ - * 3 4 5 6 7 Â Â Â Â Â Â Â Â Â Â Â Â The result is 3 4 * 5 - 6 / 7 *." }, { "title": "Time Complexity", "url": "/posts/time-complexity/", "categories": "Code, Others, Time Complexity, Data Structure", "tags": "time complexity, data structure", "date": "2022-09-17 18:05:00 +0800", "snippet": "Big-O (O) å®šç¾© f(n) = O(g(n)) iff there exists c, n0 &gt; 0 such that f(n)\\(\\le\\) c \\(\\cdot\\) g(n) for all n \\(\\ge\\) n0 æ„ç¾© åªéœ€è¦æ‰¾åˆ° n0 å’Œå¸¸æ•¸cä½¿å¾—æ‰€æœ‰ç¬¦åˆn\\(\\ge\\) n0 çš„æ•´æ•¸æ»¿è¶³f(n) \\(\\le\\) c \\(\\cdot\\) g(n)ï¼Œå‰‡f(n) = O(g(n))æˆç«‹ã€‚ä¾‹å­ 3n+2 = O(n) ç•¶ c=4, n0 = 2 æ™‚ï¼Œ3n+2 \\(\\le\\) 4n for all n \\(\\ge\\) 2 100n+6 = O(n) ç•¶ c=101, n0 = 6 æ™‚ï¼Œ100n+6 \\(\\le\\) 101n for all n \\(\\ge\\) 6 10n2+4n+2 = O(n2) ç•¶ c=11, n0 = 5 æ™‚ï¼Œ10n2+4n+2 \\(\\le\\) 11n2 for all n \\(\\ge\\) 5 ç‰¹æ€§ f(n) = O(g(n)) ä»£è¡¨ O(g(n)) ç‚º f(n) çš„upper boundï¼Œå› æ­¤ n = O(n) = O(n2.5) = O(n3) = O(nn)ã€‚ä¸€èˆ¬æœƒè®“ g(n) çš„å€¼æ„ˆå°æ„ˆå¥½ã€‚ Big-Oå¸¸ç”¨æ–¼å–å¾—ä¸€å€‹ç¨‹å¼çš„ worst-case running timeã€‚Big-Omega(\\(\\Omega\\)) å®šç¾© f(n) = \\(\\Omega\\)(g(n)) iff there exists c, n0 &gt; 0 such that f(n)\\(\\ge\\) c \\(\\cdot\\) g(n) for all n \\(\\ge\\) n0 æ„ç¾© åªéœ€è¦æ‰¾åˆ° n0 å’Œå¸¸æ•¸cä½¿å¾—æ‰€æœ‰ç¬¦åˆn\\(\\ge\\) n0 çš„æ•´æ•¸æ»¿è¶³f(n) \\(\\ge\\) c \\(\\cdot\\) g(n)ï¼Œå‰‡f(n) = \\(\\Omega\\)(g(n))æˆç«‹ã€‚ä¾‹å­ 3n+2 = \\(\\Omega\\)(n) ç•¶ c=3, n0 = 1 æ™‚ï¼Œ3n+2 \\(\\ge\\) 3n for all n \\(\\ge\\) 1 100n+6 = \\(\\Omega\\)(n) ç•¶ c=100, n0 = 1 æ™‚ï¼Œ100n+6 \\(\\ge\\) 100n for all n \\(\\ge\\) 1 10n2+4n+2 = \\(\\Omega\\)(n2) ç•¶ c=1, n0 = 1 æ™‚ï¼Œ10n2+4n+2 \\(\\ge\\) n2 for all n \\(\\ge\\) 1 ç‰¹æ€§ f(n) = \\(\\Omega\\)(g(n)) ä»£è¡¨ \\(\\Omega\\)(g(n)) ç‚º f(n) lower boundã€‚ \\(\\Omega\\) å¸¸ç”¨æ–¼å–å¾—ä¸€å€‹ç¨‹å¼çš„ best-case running timeã€‚Big-Theta(\\(\\theta\\)) å®šç¾© f(n) = \\(\\theta\\)(g(n)) iff f(n) = O(g(n)) and f(n) = \\(\\Omega\\)(g(n))ã€‚ æ„ç¾© æ¯” Big-O å’Œ Big-\\(\\Omega\\) ç²¾ç¢ºã€‚ä¾‹å­ 3n+2 = \\(\\theta\\)(n) 100n+6 = \\(\\theta\\)(n) 10n2+4n+2 = \\(\\theta\\)(n2)ç‰¹æ€§ f(n) = \\(\\theta\\)(g(n)) ä»£è¡¨ \\(\\theta\\)(g(n)) ç‚º f(n) tight boundã€‚ \\(\\theta\\) å¸¸ç”¨æ–¼å–å¾—ä¸€å€‹ç¨‹å¼çš„ average-case running timeã€‚" }, { "title": "CSES Apple Division", "url": "/posts/cses-Apple-Division/", "categories": "Code, CSES", "tags": "cses, dfs", "date": "2022-09-15 11:40:00 +0800", "snippet": "Problem Linkä½œæ³•DFSCode#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;ll n, sum;vector&lt;ll&gt; apples;ll dfs(ll pos, ll cur){ if(pos == n){ return abs(sum - 2 * cur); } ll ret = LLONG_MAX; for(int i=pos; i&lt;n; i++){ ret = min(ret, dfs(i + 1, cur + apples[i])); } return ret;}int main(){ cin &gt;&gt; n; apples.resize(n); for(ll i=0; i&lt;n; i++){ cin &gt;&gt; apples[i]; sum += apples[i]; } cout &lt;&lt; dfs(0, 0);}" }, { "title": "CSES Removal Game", "url": "/posts/cses-removal-game/", "categories": "Code, CSES", "tags": "cses, dp", "date": "2022-09-13 00:20:00 +0800", "snippet": "Problem Linkä½œæ³•DPCode#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;vector&lt;ll&gt; score(5005);vector&lt;vector&lt;ll&gt;&gt; dp(5005, vector&lt;ll&gt;(5005));vector&lt;vector&lt;bool&gt;&gt; seen(5005, vector&lt;bool&gt;(5005));ll f(int l, int r){ if(l == r) return score[r] - score[l-1]; if(seen[l][r]) return dp[l][r]; seen[l][r] = true; dp[l][r] = score[r] - score[l-1] - min(f(l+1, r), f(l, r-1)); return dp[l][r];}int main(){ int n; cin &gt;&gt; n; for(int i=1; i&lt;=n; i++){ cin &gt;&gt; score[i]; score[i] += score[i-1]; } cout &lt;&lt; f(1, n); return 0;}" }, { "title": "CSES Money Sums", "url": "/posts/cses-money-sums/", "categories": "Code, CSES", "tags": "cses, dp", "date": "2022-09-11 22:19:00 +0800", "snippet": "Problem Linkä½œæ³• set bitsetCode1#include &lt;bits/stdc++.h&gt;using namespace std;set&lt;int&gt; s;int main(){ int n; cin &gt;&gt; n; for(int i=0; i&lt;n; i++){ int x; cin &gt;&gt; x; vector&lt;int&gt; tmp; for(auto&amp; i:s) tmp.emplace_back(i + x); for(auto&amp; i:tmp) s.emplace(i); s.emplace(x); } cout &lt;&lt; s.size() &lt;&lt; '\\n'; for(auto&amp; i:s) cout &lt;&lt; i &lt;&lt; ' '; return 0;}Code2#include &lt;bits/stdc++.h&gt;using namespace std;bitset&lt;1000005&gt; bs;int main(){ int n, x; cin &gt;&gt; n; bs[0] = 1; while(n--){ cin &gt;&gt; x; bs |= (bs &lt;&lt; x); } cout &lt;&lt; bs.count()-1 &lt;&lt; '\\n'; for(int i=1; i&lt;=1000000; i++){ if(bs[i]) cout &lt;&lt; i &lt;&lt; ' '; } return 0;}" }, { "title": "CSES Rectangle Cutting", "url": "/posts/cses-rectangle-cutting/", "categories": "Code, CSES", "tags": "cses, dp", "date": "2022-09-11 21:41:00 +0800", "snippet": "Problem Linkä½œæ³•DPCode#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;vector&lt;int&gt;&gt; dp(505, vector&lt;int&gt;(505, INT_MAX));int main(){ int a, b; cin &gt;&gt; a &gt;&gt; b; for(int i=1; i&lt;=a; i++){ for(int j=1; j&lt;=b; j++){ if(i == j){ dp[i][j] = 0; continue; } for(int k=1; k&lt;i; k++){ dp[i][j] = min(dp[i][j], dp[i-k][j] + dp[k][j] + 1); } for(int k=1; k&lt;j; k++){ dp[i][j] = min(dp[i][j], dp[i][j-k] + dp[i][k] + 1); } } } cout &lt;&lt; dp[a][b]; return 0;}" }, { "title": "CSES Edit Distance", "url": "/posts/cses-edit-distance/", "categories": "Code, CSES", "tags": "cses, dp", "date": "2022-09-11 20:58:00 +0800", "snippet": "Problem Linkä½œæ³•DPCode#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;vector&lt;int&gt;&gt; dp(5005, vector&lt;int&gt;(5005));int main(){ string s, t; cin &gt;&gt; s &gt;&gt; t; for(int i=1; i&lt;=5000; i++){ dp[i][0] = dp[0][i] = i; } for(int i=1; i&lt;=s.size(); i++){ for(int j=1; j&lt;=t.size(); j++){ if(s[i-1] == t[j-1]) dp[i][j] = dp[i-1][j-1]; else dp[i][j] = min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1])) + 1; } } cout &lt;&lt; dp[s.size()][t.size()]; return 0;}" }, { "title": "CSES Counting Towers", "url": "/posts/cses-counting-towers/", "categories": "Code, CSES", "tags": "cses, dp", "date": "2022-09-11 18:44:00 +0800", "snippet": "Problem Linkä½œæ³•DPCode#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const ll M = 1e9+7;vector&lt;vector&lt;ll&gt;&gt; dp(1000005, vector&lt;ll&gt;(2));int main(){ dp[1][0] = dp[1][1] = 1; for(int i=2; i&lt;=1000000; i++){ dp[i][0] = (dp[i-1][0]*2 + dp[i-1][1]) % M; dp[i][1] = (dp[i-1][0] + dp[i-1][1]*4) % M; } int t; cin &gt;&gt; t; while(t--){ int n; cin &gt;&gt; n; cout &lt;&lt; (dp[n][0] + dp[n][1]) % M &lt;&lt; '\\n'; } return 0;}" }, { "title": "CSES Array Description", "url": "/posts/cses-array-description/", "categories": "Code, CSES", "tags": "cses, dp", "date": "2022-09-11 18:16:00 +0800", "snippet": "Problem Linkä½œæ³•DPCode#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const ll M = 1e9+7;vector&lt;vector&lt;ll&gt;&gt; dp(100005, vector&lt;ll&gt;(105));int main(){ int n, m, x; cin &gt;&gt; n &gt;&gt; m &gt;&gt; x; if(x == 0){ for(int i=1; i&lt;=m; i++) dp[1][i]++; }else dp[1][x]++; for(int i=2; i&lt;=n; i++){ cin &gt;&gt; x; if(x == 0){ for(int j=1; j&lt;=m; j++) dp[i][j] = (dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j+1]) % M; }else dp[i][x] = (dp[i-1][x] + dp[i-1][x-1] + dp[i-1][x+1]) % M; } ll res = 0; for(int i=1; i&lt;=m; i++) res += dp[n][i]; cout &lt;&lt; res % M; return 0;}" }, { "title": "CSES Book Shop", "url": "/posts/cses-book-shop/", "categories": "Code, CSES", "tags": "cses, dp", "date": "2022-09-11 13:31:00 +0800", "snippet": "Problem Linkä½œæ³•DPCode#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;vector&lt;int&gt;&gt; dp(1005, vector&lt;int&gt;(100005));vector&lt;pair&lt;int, int&gt;&gt; books(100005);int main(){ int n, x; cin &gt;&gt; n &gt;&gt; x; for(int i=1; i&lt;=n; i++){ cin &gt;&gt; books[i].first; } for(int i=1; i&lt;=n; i++){ cin &gt;&gt; books[i].second; } for(int i=1; i&lt;=n; i++){ for(int j=0; j&lt;=x; j++){ dp[i][j] = dp[i-1][j]; if(j - books[i].first &gt;= 0) dp[i][j] = max(dp[i][j], dp[i-1][j-books[i].first] + books[i].second); } } cout &lt;&lt; dp[n][x]; return 0;}" }, { "title": "CSES Grid Paths", "url": "/posts/cses-grid-paths/", "categories": "Code, CSES", "tags": "cses, dp", "date": "2022-09-11 13:06:00 +0800", "snippet": "Problem Linkä½œæ³•DPCode#include &lt;bits/stdc++.h&gt;using namespace std;const int M = 1e9+7;vector&lt;vector&lt;int&gt;&gt; dp(1005, vector&lt;int&gt;(1005));int main(){ int n; cin &gt;&gt; n; char c; dp[0][1] = 1; for(int i=1; i&lt;=n; i++){ for(int j=1; j&lt;=n; j++){ cin &gt;&gt; c; if(c == '.') dp[i][j] = (dp[i-1][j] + dp[i][j-1]) % M; } } cout &lt;&lt; dp[n][n]; return 0;}" }, { "title": "CSES Removing Digits", "url": "/posts/cses-removing-digits/", "categories": "Code, CSES", "tags": "cses, dp", "date": "2022-09-11 12:53:00 +0800", "snippet": "Problem Linkä½œæ³•DPCode#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; dp(1000006, INT_MAX);bool valid(int v, int k){ while(v){ if(v % 10 == k) return true; v /= 10; } return false;}int main(){ int n; cin &gt;&gt; n; dp[0] = 0; for(int i=0; i&lt;=n; i++){ for(int j=1; j&lt;=9; j++){ if(i - j &gt;= 0 &amp;&amp; valid(i, j)) dp[i] = min(dp[i], dp[i-j]+1); } } cout &lt;&lt; dp[n]; return 0;}" }, { "title": "CSES Coin Combinations II", "url": "/posts/cses-coin-combinations-II/", "categories": "Code, CSES", "tags": "cses, dp", "date": "2022-09-11 12:42:00 +0800", "snippet": "Problem Linkä½œæ³•DPCode#include &lt;bits/stdc++.h&gt;const int M = 1e9+7;using namespace std;vector&lt;int&gt; dp(1000005), coins(105);int main(){ int n, x; cin &gt;&gt; n &gt;&gt; x; for(int i=0; i&lt;n; i++){ cin &gt;&gt; coins[i]; } dp[0] = 1; for(int i=0; i&lt;n; i++){ for(int j=1; j&lt;=x; j++){ if(j - coins[i] &gt;= 0) dp[j] = (dp[j] + dp[j - coins[i]]) % M; } } cout &lt;&lt; dp[x]; return 0;}" }, { "title": "CSES Coin Combinations I", "url": "/posts/cses-coin-combinations-I/", "categories": "Code, CSES", "tags": "cses, dp", "date": "2022-09-11 12:37:00 +0800", "snippet": "Problem Linkä½œæ³•DPCode#include &lt;bits/stdc++.h&gt;const int M = 1e9+7;using namespace std;vector&lt;int&gt; dp(1000005), coins(105);int main(){ int n, x; cin &gt;&gt; n &gt;&gt; x; for(int i=0; i&lt;n; i++){ cin &gt;&gt; coins[i]; } dp[0] = 1; for(int i=1; i&lt;=x; i++){ for(int j=0; j&lt;n; j++){ if(i - coins[j] &gt;= 0) dp[i] = (dp[i] + dp[i - coins[j]]) % M; } } cout &lt;&lt; dp[x]; return 0;}" }, { "title": "CSES Minimizing Coins", "url": "/posts/cses-minimizing-coins/", "categories": "Code, CSES", "tags": "cses, dp", "date": "2022-09-11 12:25:00 +0800", "snippet": "Problem Linkä½œæ³•DPCode#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; dp(1000005, INT_MAX), coins(105);int main(){ int n, x; cin &gt;&gt; n &gt;&gt; x; for(int i=0; i&lt;n; i++){ cin &gt;&gt; coins[i]; } dp[0] = 0; for(int i=1; i&lt;=x; i++){ for(int j=0; j&lt;n; j++){ if(i - coins[j] &gt;= 0 &amp;&amp; dp[i-coins[j]] != INT_MAX) dp[i] = min(dp[i], dp[i-coins[j]]+1); } } if(dp[x] == INT_MAX) cout &lt;&lt; -1; else cout &lt;&lt; dp[x]; return 0;}" }, { "title": "CSES Dice Combinations", "url": "/posts/cses-dice-combinations/", "categories": "Code, CSES", "tags": "cses, dp", "date": "2022-09-11 12:07:00 +0800", "snippet": "Problem Linkä½œæ³•DPCode#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const ll M = 1e9+7;vector&lt;ll&gt; dp(1000005);int main(){ int n; cin &gt;&gt; n; dp[0] = 1; for(int i=0; i&lt;=n; i++){ for(int j=1; j &lt;= 6; j++){ if(i-j &gt;= 0) dp[i] = (dp[i] + dp[i-j]) % M; } } cout &lt;&lt; dp[n]; return 0;}" }, { "title": "TIOJ 1226 . HéŠæˆ²", "url": "/posts/tioj-1226/", "categories": "Code, TIOJ", "tags": "tioj, topological sort", "date": "2022-09-01 16:50:00 +0800", "snippet": "Problem Linkä½œæ³•æ‹“æ’²æ’åºï¼Œä¸¦ä»¥dpè¨˜éŒ„èƒ½é”åˆ°æŸé»çš„è·¯å¾‘çš„æ•¸é‡ã€‚å‡è¨­å¾ a é»åˆ° b é»çš„æ¬Šé‡ç‚º 10ï¼Œä¸”å¾ 0 é»åˆ° a é»æœ‰ 3 ç¨®è·¯å¾‘ï¼Œå‰‡ b é»çš„ç¸½èŠ±è²» = a é»çš„ç¸½èŠ±è²» + 10(æ¬Šé‡) * 3(è·¯å¾‘æ•¸)ã€‚Code#include &lt;bits/stdc++.h&gt;#define M 32768#define ll long longusing namespace std;int main(){ ios_base::sync_with_stdio(0); cin.tie(0); ll t; cin &gt;&gt; t; for(ll g=1; g&lt;=t; g++){ vector&lt;vector&lt;pair&lt;ll, ll&gt;&gt;&gt; e(1005); vector&lt;string&gt; name(105); vector&lt;ll&gt; val(1005), task(1005), dp(1005); ll N, V, E; cin &gt;&gt; N &gt;&gt; V &gt;&gt; E; for(ll i=0; i&lt;N; i++){ cin &gt;&gt; name[i]; } while(E--){ ll from, to, w; cin &gt;&gt; from &gt;&gt; to &gt;&gt; w; e[from].emplace_back(to, w%M); task[to]++; } queue&lt;ll&gt; q; q.emplace(0); dp[0] = 1; while(!q.empty()){ ll cur = q.front(); q.pop(); for(auto&amp; i:e[cur]){ val[i.first] += (val[cur] + i.second*dp[cur])%M; dp[i.first] += dp[cur]; task[i.first]--; if(!task[i.first]) q.emplace(i.first); } } cout &lt;&lt; \"Game #\" &lt;&lt; g &lt;&lt; '\\n'; for(ll i=0; i&lt;N; i++){ cout &lt;&lt; name[i] &lt;&lt; \": \" &lt;&lt; val[i+1]%M &lt;&lt; '\\n'; } } return 0;}" }, { "title": "TIOJ 1092. A.è·³æ ¼å­éŠæˆ²", "url": "/posts/tioj-1092/", "categories": "Code, TIOJ", "tags": "tioj", "date": "2022-09-01 16:41:00 +0800", "snippet": "Problem Linkä½œæ³•å¾çµ‚é»é–‹å§‹å¾€å›æ¨ã€‚è€ƒæ…®æŸåœ“åœˆçš„æ‰€æœ‰ä¸‹ä¸€æ­¥ï¼Œè‹¥å­˜åœ¨æŸä¸€æ­¥ä½¿çš„ç©å®¶èƒ½é”åˆ°å¿…å‹çš„é»ï¼Œå‰‡è©²åœ“åœˆå¿…æ•—ï¼Œå› ç‚ºå°æ–¹ä¸€å®šæœƒå¾€å¿…å‹çš„åœ“åœˆèµ°ã€‚åä¹‹ï¼Œå¦‚æœæ‰€æœ‰ä¸‹ä¸€æ­¥çš†ç‚ºå¿…æ•—çš„é»ï¼Œå‰‡è©²åœ“åœˆå¿…å‹ï¼Œå› ç‚ºä¸ç®¡æ€æ¨£å°æ–¹éƒ½æœƒè¼¸ã€‚Code#include &lt;bits/stdc++.h&gt;using namespace std; vector&lt;vector&lt;int&gt;&gt; e(10005);int out[10005], state[10005];int N, E;string name;int main(){ ios_base::sync_with_stdio(0); cin.tie(0); // 1 = win, 0 = lose while(cin &gt;&gt; N &gt;&gt; E, (N || E)){ for(auto&amp; v:e) v.clear(); memset(out, 0, sizeof(out)); memset(state, 0, sizeof(state)); while(E--){ int from, to; cin &gt;&gt; from &gt;&gt; to; e[to].emplace_back(from); out[from]++; } cin &gt;&gt; name; state[N] = 1; // çµ‚é» queue&lt;int&gt; q; q.emplace(N); while(!q.empty()){ int cur = q.front(); q.pop(); for(int&amp; i:e[cur]){ if(state[cur] == 1){ out[i] = state[i] = 0; q.emplace(i); }else{ out[i]--; if(out[i] == 0){ q.emplace(i); state[i] = 1; } } } } if(state[1] == 1){ cout &lt;&lt; name &lt;&lt; '\\n'; }else if(name == \"Moumou\"){ cout &lt;&lt; \"Mimi\\n\"; }else{ cout &lt;&lt; \"Moumou\\n\"; } } return 0;}" }, { "title": "CSES Salary Queries", "url": "/posts/cses-salary-queries/", "categories": "Code, CSES", "tags": "cses, segment tree", "date": "2022-08-23 21:11:00 +0800", "snippet": "Problem Linkä½œæ³• é›¢æ•£åŒ–(discretization) + ç·šæ®µæ¨¹(segment tree) é›¢æ•£åŒ–(discretization) + BIT(binary indexed tree) Code1#include &lt;bits/stdc++.h&gt;#define io ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);using namespace std;vector&lt;int&gt; v(2e5+10), t, s(1e7+10);vector&lt;vector&lt;int&gt;&gt; op;int query(int id, int l, int r, int ql, int qr){ if(qr == 0 || ql &gt; r || qr &lt; l) return 0; if(ql &lt;= l &amp;&amp; qr &gt;= r) return s[id]; int m = (l+r)/2; return query(id*2, l, m, ql, qr) + query(id*2+1, m+1, r, ql, qr);}void update(int id, int l, int r, int v, int target_id){ if(l == r){ s[id] += v; return; } int m = (l+r)/2; m &gt;= target_id ? update(id*2, l, m, v, target_id) : update(id*2+1, m+1, r, v, target_id); s[id] = s[id*2] + s[id*2+1];}int relabel(int x){ return lower_bound(t.begin(), t.end(), x) - t.begin() + 1;}int relabel_upper(int x){ return upper_bound(t.begin(), t.end(), x) - t.begin();}int main(){ io int n, q; cin &gt;&gt; n &gt;&gt; q; for(int i=1; i&lt;=n; i++){ cin &gt;&gt; v[i]; t.emplace_back(v[i]); } for(int i=1; i&lt;=q; i++){ char c; int a, b; cin &gt;&gt; c &gt;&gt; a &gt;&gt; b; if(c == '!') t.emplace_back(b); op.emplace_back(vector&lt;int&gt;{c == '!', a, b}); } sort(t.begin(), t.end()); t.erase(unique(t.begin(), t.end()), t.end()); for(int i=1; i&lt;=n; i++){ update(1, 1, t.size(), 1, relabel(v[i])); } for(int i=0; i&lt;q; i++){ if(op[i][0] == 1){ update(1, 1, t.size(), -1, relabel(v[op[i][1]])); update(1, 1, t.size(), 1, relabel(op[i][2])); v[op[i][1]] = op[i][2]; }else{ cout &lt;&lt; query(1, 1, t.size(), 1, relabel_upper(op[i][2])) - query(1, 1, t.size(), 1, relabel(op[i][1])-1) &lt;&lt; '\\n'; } } return 0;}Code2#include &lt;bits/stdc++.h&gt;#define io ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);using namespace std;vector&lt;int&gt; v(2e5+10), t, BIT(4e5+10);vector&lt;vector&lt;int&gt;&gt; op;void update(int x, int d){ x = lower_bound(t.begin(), t.end(), x) - t.begin() + 1; while(x &lt;= t.size()){ BIT[x] += d; x += x &amp; (-x); }}int find(int x){ int ret = 0; while(x &gt; 0){ ret += BIT[x]; x -= x &amp; (-x); } return ret;}int query(int l, int r){ int a = lower_bound(t.begin(), t.end(), l) - t.begin(); int b = upper_bound(t.begin(), t.end(), r) - t.begin(); return find(b) - find(a);}int main(){ io int n, q; cin &gt;&gt; n &gt;&gt; q; for(int i=1; i&lt;=n; i++){ cin &gt;&gt; v[i]; t.emplace_back(v[i]); } for(int i=1; i&lt;=q; i++){ char c; int a, b; cin &gt;&gt; c &gt;&gt; a &gt;&gt; b; if(c == '!') t.emplace_back(b); op.emplace_back(vector&lt;int&gt;{c == '!', a, b}); } sort(t.begin(), t.end()); t.erase(unique(t.begin(), t.end()), t.end()); for(int i=1; i&lt;=n; i++){ update(v[i], 1); } for(int i=0; i&lt;q; i++){ if(op[i][0] == 1){ update(v[op[i][1]], -1); update(op[i][2], 1); v[op[i][1]] = op[i][2]; }else{ cout &lt;&lt; query(op[i][1], op[i][2]) &lt;&lt; '\\n'; } } return 0;}" }, { "title": "LeetCode-128. Longest Consecutive Sequence", "url": "/posts/leetcode-128/", "categories": "Code, LeetCode", "tags": "leetcode", "date": "2022-08-18 15:20:00 +0800", "snippet": "Problem Linké¡Œç›®æ•˜è¿°çµ¦ä½ ä¸€çµ„æœªæ’åºçš„é™£åˆ—ï¼Œè¼¸å‡ºæœ€é•·é€£çºŒæ•¸å­—çš„åºåˆ—é•·åº¦ã€‚(å¿…é ˆåœ¨O(n)æ™‚é–“è¤‡é›œåº¦å…§)Example 1:Input: nums = [100,4,200,1,3,2]Output: 4Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.ä½œæ³•æˆ‘å€‘å¯ä»¥å°‡æ‰€æœ‰æ•¸å­—å­˜åœ¨hashè£¡ï¼Œè—‰æ­¤å¿«é€Ÿåˆ¤æ–·æŸæ•¸å­—æ˜¯å¦å­˜åœ¨ã€‚æ¥è‘—éæ­·æ‰€æœ‰æ•¸å­—ï¼Œå¿«é€Ÿåˆ¤æ–·è©²æ•¸å­—æ˜¯å¦ç‚ºé€£çºŒæ•¸åˆ—çš„ç¬¬ä¸€é …ï¼Œå¦‚æœæ˜¯ï¼Œå°±ç¹¼çºŒåˆ¤æ–·è©²æ•¸å­—çš„ä¸‹ä¸€é …ã€ä¸‹å…©é …ã€ä¸‹ä¸‰é …â€¦æ˜¯å¦å­˜åœ¨ï¼ŒåŒæ™‚è¨˜éŒ„å®ƒçš„æœ€é•·é•·åº¦ã€‚Codeclass Solution {public: int longestConsecutive(vector&lt;int&gt;&amp; nums) { unordered_set&lt;int&gt; st; for(int&amp; num:nums) st.emplace(num); int ret = 0; for(auto&amp; num:st){ if(!st.count(num-1)){ int len = 1; while(st.count(num+len)) len++; ret = max(ret, len); } } return ret; }};" }, { "title": "CSES Fibonacci Numbers", "url": "/posts/cses-fibonacci-numbers/", "categories": "Code, CSES", "tags": "cses, exponentiation by squaring", "date": "2022-08-16 15:52:00 +0800", "snippet": "Problem Linkä½œæ³•çŸ©é™£ + å¿«é€Ÿå†ªCode#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const ll M = 1e9+7;vector&lt;ll&gt; matrix_cal(vector&lt;ll&gt; a, vector&lt;ll&gt;b){ vector&lt;ll&gt; ret(4); ret[0] = (a[0]*b[0] + a[1]*b[2])%M; ret[1] = (a[0]*b[1] + a[1]*b[3])%M; ret[2] = (a[2]*b[0] + a[3]*b[2])%M; ret[3] = (a[2]*b[1] + a[3]*b[3])%M; return ret;}vector&lt;ll&gt; binpow(ll n){ if(n == -1) return vector&lt;ll&gt;{0}; if(n == 0 || n == 1) return vector&lt;ll&gt;{1, 1, 1, 0}; vector&lt;ll&gt; hf = binpow(n/2); return n % 2 ? matrix_cal(matrix_cal(hf, hf), vector&lt;ll&gt;{1, 1, 1, 0}) : matrix_cal(hf, hf);}int main(){ ll n; cin &gt;&gt; n; cout &lt;&lt; binpow(n-1)[0] &lt;&lt; '\\n'; return 0;}" }, { "title": "UVA-10917 Walk Through the Forest", "url": "/posts/uva-10917/", "categories": "Code, UVA", "tags": "uva, dijkstra, dp", "date": "2022-08-16 15:42:00 +0800", "snippet": "Problem Linkä½œæ³•Dijkstra + DPCode#include &lt;bits/stdc++.h&gt;using namespace std;struct node{ int id, cost; node(){} node(int i, int c):id(i),cost(c){} bool operator&lt;(const node&amp; a)const{ return cost &gt; a.cost; }};vector&lt;vector&lt;int&gt;&gt; neighbors;vector&lt;bool&gt; seen;vector&lt;int&gt; shortest, dp;int path[1050][1050];void init(int N){ dp.clear(); dp.resize(N+1, -1); neighbors.clear(); neighbors.resize(N+1); seen.clear(); seen.resize(N+1); shortest.clear(); shortest.resize(N+1, INT_MAX); shortest[2] = 0;}int dfs(int id){ if(id == 2) return 1; if(~dp[id]) return dp[id]; int s = 0; for(int&amp; i:neighbors[id]){ if(shortest[i] &lt; shortest[id]) s += dfs(i); } dp[id] = s; return s;}int main(){ ios_base::sync_with_stdio(0); cin.tie(0); int N, M; while(cin &gt;&gt; N, N){ cin &gt;&gt; M; init(N); while(M--){ int a, b, d; cin &gt;&gt; a &gt;&gt; b &gt;&gt; d; neighbors[a].emplace_back(b); neighbors[b].emplace_back(a); path[a][b] = path[b][a] = d; } priority_queue&lt;node&gt; pq; pq.emplace(node(2, 0)); while(!pq.empty()){ node cur = pq.top(); pq.pop(); if(seen[cur.id]) continue; else seen[cur.id] = true; for(int&amp; i:neighbors[cur.id]){ if(!seen[i]){ if(cur.cost + path[i][cur.id] &lt; shortest[i]){ shortest[i] = cur.cost + path[i][cur.id]; pq.emplace(node(i, shortest[i])); } } } } cout &lt;&lt; dfs(1) &lt;&lt; '\\n'; } return 0;}" }, { "title": "ZeroJudge-c152 å­¸èªæ³•çš„å‰ç½®ä½œæ¥­(?", "url": "/posts/zerojudge-c152/", "categories": "Code, ZeroJudge", "tags": "zerojudge, dijkstra", "date": "2022-08-16 11:04:00 +0800", "snippet": "Problem Linkä½œæ³•å…©æ¬¡ DijkstraCode#include &lt;bits/stdc++.h&gt;using namespace std;struct state{ state(){} state(int i, float c): id(i), cost(c){} state(int i, float c, float d): id(i), cost(c), dis(d){} int id; float cost, dis; bool operator&lt;(const state&amp; n) const{ return cost &gt;= n.cost; }};struct node{ node(){} node(int i, int d, float t):id(i), dis(d), time(t){} int id, dis; float time;};int main(){ ios_base::sync_with_stdio(0); cin.tie(0); int t; cin &gt;&gt; t; while(t--){ int N, M, A, B; cin &gt;&gt; N &gt;&gt; M &gt;&gt; A &gt;&gt; B; vector&lt;vector&lt;node&gt;&gt; neighbors(N+1); vector&lt;bool&gt; seen(N+1); while(M--){ int a, b, d, v; cin &gt;&gt; a &gt;&gt; b &gt;&gt; d &gt;&gt; v; neighbors[a].emplace_back(node(b, d, d/(float)v)); neighbors[b].emplace_back(node(a, d, d/(float)v)); } priority_queue&lt;state&gt; pq; // first dijkstra pq.emplace(state(A, 0)); while(!pq.empty()){ state cur = pq.top(); pq.pop(); if(seen[cur.id]) continue; if(cur.id == B){ cout &lt;&lt; (int)cur.cost &lt;&lt; ' '; break; } seen[cur.id] = true; for(node&amp; i:neighbors[cur.id]){ if(!seen[i.id]){ pq.emplace(state(i.id, cur.cost + i.dis)); } } } // init while(!pq.empty()) pq.pop(); for(int i=0; i&lt;=N; i++) seen[i] = false; // second dijkstra pq.emplace(state(A, 0, 0)); while(!pq.empty()){ state cur = pq.top(); pq.pop(); if(seen[cur.id]) continue; if(cur.id == B){ cout &lt;&lt; (int)cur.dis &lt;&lt; '\\n'; break; } seen[cur.id] = true; for(node&amp; i:neighbors[cur.id]){ if(!seen[i.id]){ pq.emplace(state(i.id, cur.cost + i.time, cur.dis + i.dis)); } } } } return 0;}" }, { "title": "ZeroJudge-a007 åˆ¤æ–·è³ªæ•¸", "url": "/posts/zerojudge-a007/", "categories": "Code, ZeroJudge", "tags": "zerojudge", "date": "2022-08-15 23:01:00 +0800", "snippet": "Problem Linké¡Œç›®æ•˜è¿°è¼¸å…¥å¤šç­†æ¸¬è³‡ï¼Œæ¯ç­†æ¸¬è³‡åŒ…å«ä¸€å€‹æ•´æ•¸ x (2 â‰¦ x â‰¦ 2147483647)ï¼Œåˆ¤æ–· x æ˜¯å¦ç‚ºè³ªæ•¸ã€‚ä½œæ³•å¾ˆæ˜é¡¯çš„ï¼Œé€™é“é¡Œç›®å¿…é ˆå»ºç«‹è³ªæ•¸è¡¨ä¾†æ¸›å°‘åˆ¤æ–·çš„æ™‚é–“ï¼Œé€™é‚Šé¸æ“‡ä½¿ç”¨åŸƒå¼ç¯©æ³•ã€‚ç„¶è€Œï¼Œç”±æ–¼ x çš„å€¼æœ€å¤šå¯é” 2147483647ï¼Œç›´æ¥é–‹é™£åˆ—åˆ¤æ–·çš„è©±æœƒç‚¸é–‹ã€‚æˆ‘å€‘å¯ä»¥å¾ç°¡å–®çš„å•é¡Œè‘—æ‰‹: å¦‚ä½•åˆ¤æ–·ä¸€å€‹æ•¸æ˜¯è³ªæ•¸?å°æ–¼13è€Œè¨€ï¼Œåªéœ€åˆ¤æ–· â‰¦ \\(\\sqrt{13}\\) çš„è³ªæ•¸å°±å¥½ï¼Œå¦‚æœå‰åŠéƒ¨çš„æ•¸éƒ½ç„¡æ³•æ•´é™¤ 13ï¼Œå¾ŒåŠéƒ¨çš„éƒ¨åˆ†ä¹Ÿä¸å¯èƒ½æ•´é™¤ã€‚åŒç†ï¼Œè¦åˆ¤æ–· x = 2147483647 æ˜¯å¦ç‚ºè³ªæ•¸ï¼Œåªéœ€è¦å°‡ x é™¤ä»¥ â‰¦ \\(\\sqrt{x}\\) çš„è³ªæ•¸ä¾†åˆ¤æ–·å°±å¥½ã€‚\\(\\sqrt{2147483647}\\) çš„æ•´æ•¸éƒ¨åˆ†ç‚º 46340ï¼Œå› æ­¤è³ªæ•¸è¡¨å»ºåˆ° 46340 å³å¯ã€‚Code#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; v;vector&lt;bool&gt; is_prime(46341, true);int main(){ ios_base::sync_with_stdio(0); cin.tie(0); is_prime[1] = false; for(int i=2; i&lt;=46340; i++){ // å»ºè¡¨ if(!is_prime[i]) continue; else v.emplace_back(i); // å°æ–¼46341çš„è³ªæ•¸ for(int j = i*i; j&lt;= 46340; j+=i){ is_prime[j] = false; } } int n; while(cin &gt;&gt; n){ if(n &gt; 46340){ bool flag = false; for(int&amp; i:v){ if(n % i == 0){ flag = true; break; } } if(flag) cout &lt;&lt; \"éè³ªæ•¸\\n\"; else cout &lt;&lt; \"è³ªæ•¸\\n\"; }else{ if(is_prime[n]) cout &lt;&lt; \"è³ªæ•¸\\n\"; else cout &lt;&lt; \"éè³ªæ•¸\\n\"; } } return 0;}" } ]
